# 公司在搭建自建的大模型, 部署多套, 需要兼容OpenAI的, 并且参数中指定哪个模型, 就请求到后端的哪个模型中
# 并且需要有打字机的效果, 也就是流式输出, 这里总结了一下

# 定义一个共享字典存储模型的路由, 所有的worker共享
# 官方文档: https://github.com/openresty/lua-nginx-module?tab=readme-ov-file#lua_shared_dict
# 定义方式为: lua_shared_dict <name> <size>
# 使用方式为: ngx.shared.<name>
lua_shared_dict model_routes 10m;

# init_by_lua_block 是OpenResty提供的一个指令, 在NGINXmaster启动并fork worker进程时执行一次
# 一般用于初始化共享数据、配置变量、建立连接池等
# content_by_lua_block 每次请求都会执行, init_by_lua_block 只在 worker 启动时执行一次
# 官方文档: https://github.com/openresty/lua-nginx-module?tab=readme-ov-file#init_by_lua_block
init_by_lua_block {
    -- 使用--注释单行
    -- 模型到后端的映射表, 这里是NodePort
    ngx.shared.model_routes:set("qwen3-8b",  "http://192.168.1.1:33590")
    ngx.shared.model_routes:set("qwen3-14b",  "http://192.168.1.1:33591")
    ngx.shared.model_routes:set("qwen3-33b",  "http://192.168.1.1:37805")

    fallback_backend = "http://192.168.1.1:33590"
}


server {
    listen 443 ssl;
    server_name xxx.baidu.com;

    ssl_certificate     /usr/local/openresty/cert/server.cer;
    ssl_certificate_key /usr/local/openresty/cert/server.key;

    # 定义变量，供 proxy_pass 使用
    set $target "";

    location /v1/chat/completions {
        # 通过content_by_lua_block会引入lua脚本, 注意lua脚本的注释和NGINX不一样
        content_by_lua_block {
            -- Lua 中的变量默认都是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。
            -- 局部变量的作用域为从声明位置开始到所在语句块结束。
            -- 变量的默认值均为 nil。
            local cjson = require "cjson.safe"
            local http  = require "resty.http"

            ngx.req.read_body()
            local body_data = ngx.req.get_body_data()

            if not body_data then
                ngx.status = 400
                ngx.say("Missing request body")
                return
            end

            local body, err = cjson.decode(body_data)
            if not body or not body.model then
                ngx.status = 400
                ngx.say("Invalid JSON or missing model")
                return
            end

            local target = ngx.shared.model_routes:get(body.model) or fallback_backend

            -- 判断是否使用流式透传模式
            -- 通过body `"stream": "True"` 来控制
            local function is_stream(val)
              return val == true or val == "true" or val == "True"
            end

            local use_streaming = is_stream(body.stream)

            if use_streaming then
                ngx.header["Content-Type"] = "text/event-stream"
                ngx.header["Cache-Control"] = "no-cache"
                ngx.header["Connection"] = "keep-alive"
                chunked_transfer_encoding=on;
                -- 流式透传
                local httpc = http.new()
                if not httpc then
                    ngx.status = 500
                    ngx.say("Failed to create HTTP client")
                    return
                end
                --
                httpc:set_timeout(5000, 30000, 120000)

                -- 复制客户端 headers
                local headers = ngx.req.get_headers()
                headers["Host"] = nil
                headers["Connection"] = "close"
                headers["Transfer-Encoding"] = nil
                headers["Content-Length"] = tostring(#body_data)

                -- 解析目标 URL
                local target_host, target_port, target_path
                local protocol, host_port = target:match("^(https?)://([^/]+)")
                if host_port then
                    local host, port = host_port:match("^([^:]+):?(%d*)$")
                    target_host = host
                    target_port = tonumber(port) or (protocol == "https" and 443 or 80)
                    target_path = "/v1/chat/completions"
                else
                    ngx.status = 500
                    ngx.say("Invalid target URL: " .. target)
                    httpc:close()
                    return
                end

                -- 连接到后端
                local ok, err = httpc:connect(target_host, target_port)
                if not ok then
                    ngx.status = 502
                    ngx.say("Failed to connect to upstream: " .. (err or "unknown"))
                    httpc:close()
                    return
                end

                -- 如果是 HTTPS，进行 SSL 握手
                if protocol == "https" then
                    local ok, err = httpc:ssl_handshake(false, target_host, false)
                    if not ok then
                        ngx.status = 502
                        ngx.say("SSL handshake failed: " .. (err or "unknown"))
                        httpc:close()
                        return
                    end
                end

                -- 发送请求
                local res, err = httpc:request{
                    method = ngx.req.get_method(),
                    path = target_path,
                    body = body_data,
                    headers = headers,
                }

                if not res then
                    ngx.status = 502
                    ngx.say("All upstream requests failed: " .. (err or "unknown"))
                    httpc:close()
                    return
                end

                -- 设置响应状态
                ngx.status = res.status

                -- 复制响应头（排除某些头）
                for k, v in pairs(res.headers) do
                    if k ~= "connection" and k ~= "transfer-encoding" and k ~= "content-length" then
                        ngx.header[k] = v
                    end
                end

                -- 流式读取响应
                local reader = res.body_reader
                if reader then
                    while true do
                        local chunk, err = reader(8192)
                        if err then
                            ngx.log(ngx.ERR, "Streaming read error: ", err)
                            break
                        end
                        if not chunk then
                            break
                        end
                        ngx.print(chunk)
                        ngx.flush(true)
                    end
                else
                    -- 如果没有 body_reader，输出整个响应体
                    if res.body then
                        ngx.print(res.body)
                    end
                end

                httpc:close()
            else
                -- 非流式模式，使用 proxy_pass
                ngx.var.target = target
                return ngx.exec("@dynamic_backend")
            end
    }

  }

    location @dynamic_backend {
        proxy_pass $target;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_connect_timeout 10s;
        proxy_send_timeout 30s;
        proxy_read_timeout 120s;
        proxy_buffering off;  # 对于流式响应禁用缓冲
        proxy_cache off;      # 禁用缓存
    }
}
