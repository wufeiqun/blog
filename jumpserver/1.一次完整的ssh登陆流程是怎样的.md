#### èƒŒæ™¯ä»‹ç»

&emsp;å…¬å¸ç›®å‰åœ¨ä½¿ç”¨å¼€æºç¤¾åŒºçš„jumpserverå½“åšå ¡å’æœº, æœ€è¿‘æ­£åœ¨å¼€å‘ä¸€ä¸ªå†…éƒ¨ç³»ç»Ÿ, è¦ç”¨åˆ°jmsçš„æ¥å£, 0.3.2ç‰ˆæœ¬æ²¡æœ‰æä¾›æ¥å£, æ‰€ä»¥å‡çº§äº†jmsåˆ°äº†0.4ç‰ˆæœ¬, è¿™ä»¶äº‹å„¿æˆ‘åœ¨è´Ÿè´£, ç”±äº0.4ç‰ˆæœ¬è¿˜å¤„äºå¼€å‘é˜¶æ®µ, æ‰€ä»¥é—®é¢˜è¿˜æ˜¯å¾ˆå¤šçš„, ç”±äºå…¬å¸ä½¿ç”¨jmsä¸»è¦æ˜¯ç”¨åˆ°sshè·³æ¿æœºçš„åŠŸèƒ½, æ‰€ä»¥ä¸ºäº†ä¿è¯æœåŠ¡çš„å¯é æ€§, æˆ‘è¿˜æ˜¯è®¤çœŸç ”ç©¶äº†jmsçš„å®Œæ•´ç™»é™†æµç¨‹, ä»ä»£ç çº§åˆ«è¯´æ˜ä¸€ä¸ªå®Œæ•´çš„è¿‡ç¨‹(ä»£ç æ˜¯ç®€ç‰ˆçš„, çœå»äº†æ— å…³ç´§è¦çš„é€»è¾‘éƒ¨åˆ†), ä¸€æ˜¯æ¥ç†ä¸€ä¸‹æ€è·¯, è€Œæ˜¯ä»¥åé‡åˆ°é—®é¢˜ä¹Ÿå¯ä»¥å¿«é€Ÿæ’æŸ¥é—®é¢˜.

#### æµç¨‹è¯´æ˜

&emsp;è¿™é‡Œæš‚ä¸ä»‹ç»cocoå’Œjmsä¹‹é—´çš„appè®¤è¯, å‡è®¾å·²ç»è®¤è¯é€šè¿‡å¹¶æ¿€æ´».cocoé¡¹ç›®å…¶å®æ˜¯åŸºäºparamikoå°è£…çš„ä¸€ä¸ªsshæœåŠ¡å™¨, sshæ˜¯åŸºäºtcpä¹‹ä¸Šçš„åè®®, æ‰€ä»¥cocoå¯¹å¤–æš´éœ²çš„æ˜¯ä¸€ä¸ªtcp server, æ¥æ¥å—å®¢æˆ·ç«¯çš„è¯·æ±‚:

```python
    def run_forever(self, **kwargs):
        host = self.host
        port = self.port

        self.sock = sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind((host, port))
        sock.listen(10)

        while True:
            try: # æ¯ä¸€ä¸ªè¿æ¥ä¼šå¯åŠ¨ä¸€ä¸ªæ–°çš„çº¿ç¨‹å»å¤„ç†
                client, addr = sock.accept()
                logger.debug("Get request from %s:%s" % (addr[0], addr[1]))
                thread = threading.Thread(target=self.process_request,
                                          args=(client, addr))
                thread.daemon = True
                thread.start()
            except Exception as e:
                logger.error('Start server failed: ' + str(e))
                traceback.print_exc()
                sys.exit(1)
```

&emsp;å½“å®¢æˆ·ç«¯é€šè¿‡å¯†ç æˆ–è€…å¯†é’¥çš„æ–¹å¼è·Ÿcocoå»ºç«‹TCPè¿æ¥ä»¥å, cocoä¼šæŠŠè¿™ä¸ªTCPè¿æ¥ä¼ ç»™app.pyæ–‡ä»¶ä¸­çš„process_requestå‡½æ•°æ¥å¤„ç†è¿™ä¸ªè¯·æ±‚.process_requestå‡½æ•°ä¸ºè¿™ä¸ªè¯·æ±‚å»ºç«‹ä¿å­˜äº†ä¸€ä¸ªè¯·æ±‚ä¸Šä¸‹æ–‡rc, ç”¨äºæ•´ä¸ªè¯·æ±‚è¿‡ç¨‹ä¸­çš„å˜é‡çš„ä¿å­˜å’Œä½¿ç”¨, ç„¶åæŠŠè¿™ä¸ªè¯·æ±‚ä¼ é€’ç»™è‡ªå·±å°è£…çš„ssh server, ä¹Ÿå°±æ˜¯SSHInterfaceå¯¹è±¡, å¹¶ä¸”ä¿å­˜äº†ç”¨æˆ·å’Œssh serverçš„é“¾æ¥ç§°ä¸ºclient_channel, è¿™ä¸ªè¿æ¥ç”¨äºssh serverè·Ÿç”¨æˆ·äº¤äº’æ•°æ®. é™¤äº†è·Ÿç”¨æˆ·é—´å»ºç«‹ä¸€ä¸ªsshè¿æ¥ä»¥å¤–, ssh serverè¿˜ç»™ç”¨æˆ·å±•ç¤ºäº†ç”¨æˆ·çš„èµ„æºåˆ—è¡¨, è®©ç”¨æˆ·å»é€‰æ‹©è¦ç™»å½•çš„èµ„äº§, è¿™ä¸ªåŠŸèƒ½æ˜¯InteractiveServeråšçš„äº‹å„¿.

```python
    def process_request(self, client, addr):
        # rcæ˜¯è¯·æ±‚ä¸Šä¸‹æ–‡, æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„è¯·æ±‚ä¸Šä¸‹æ–‡
        rc = self.request_context({'REMOTE_ADDR': addr[0]})
        rc.push()
        logger.info("Get ssh request from %s" % request.environ['REMOTE_ADDR'])
        transport = paramiko.Transport(client, gss_kex=False)

        transport.add_server_key(SSHInterface.get_host_key())
        # å°†appå’Œè¯·æ±‚ä¸Šä¸‹æ–‡ä¼ é€’è¿‡å», ssh_interface å¤„ç†sshè®¤è¯å’Œå»ºç«‹è¿æ¥
        ssh_interface = SSHInterface(self, rc)

        try:
            transport.start_server(server=ssh_interface)
        except paramiko.SSHException:
            logger.warning('SSH negotiation failed.')

        _client_channel = transport.accept(20) # 20ç§’è¶…æ—¶æ—¶é—´, æ‰“å¼€ä¸€ä¸ªchannel
        g.client_channel = _client_channel

        # request.methodè¿™ä¸ªä¸Šä¸‹æ–‡å˜é‡æ˜¯åœ¨SSHè®¤è¯çš„æ—¶å€™è®¾ç½®çš„, å¯ä»¥çœ‹çœ‹interface.pyçš„å®ç°
        # å½“SSHè®¤è¯æˆåŠŸåå°±ä¼šè¯·æ±‚ä¸€ä¸ªshell
        if request.method == 'shell':
            logger.info('Client asked for a shell.')
            InteractiveServer(self).run()

        while True:
            if request.user is not None:
                break
            else:
                time.sleep(0.2)
```

&emsp;ä¸‹é¢äº†è§£ä¸€ä¸‹SSHInterfaceè¿™ä¸ªå°è£…çš„ssh server, è¿™ä¸ªç±»çš„ä¸»è¦ä½œç”¨æ˜¯è·Ÿç”¨æˆ·å»ºç«‹ä¸€ä¸ªsshè¿æ¥,å»ºç«‹è¿æ¥ä¹‹å‰å°‘äº†ä¸è®¤è¯, è¿™é‡Œçš„è®¤è¯åŒ…æ‹¬ä¸¤æ–¹é¢çš„å·¥ä½œ:

* ç¡®å®šç”¨æˆ·çš„å¯†é’¥/å¯†ç çš„æ­£ç¡®æ€§, ä¿è¯æ˜¯çœŸæ­£çš„jmsæ³¨å†Œç”¨æˆ·
* ç”±äºç”¨æˆ·çš„èµ„äº§ä¿¡æ¯/ç³»ç»Ÿç”¨æˆ·ä¿¡æ¯éƒ½ä¿å­˜åœ¨jmsä¸­, æ‰€ä»¥ç¡®è®¤ç”¨æˆ·çš„å¯†ç æ­£ç¡®ä»¥åä¼šå‘jmsç”³è¯·ä¸€ä¸ªè¯¥ç”¨æˆ·çš„token, ä»¥åæ¯ä¸ªå‘jmsçš„httpè¯·æ±‚éƒ½ä¼šæºå¸¦è¯¥tokenä¿¡æ¯æ¥è·å–ç”¨æˆ·çš„èµ„äº§ä¿¡æ¯ç­‰

ä¸‹é¢ğŸ‘‡æ¥è¯´æ˜è¿™ä¸¤ä¸ªå…·ä½“çš„æµç¨‹:

SSHInterfaceç±»ç»§æ‰¿äº†paramiko.ServerInterface, å¹¶é‡å†™äº†ä¸¤ä¸ªè®¤è¯æ–¹æ³•, `check_auth_password`ç”¨äºå¯†ç è®¤è¯, `check_auth_publickey`ç”¨äºå…¬é’¥è®¤è¯, è¿™ä¸¤ä¸ªæ–¹æ³•å…¶å®éƒ½æ˜¯è°ƒç”¨äº†`check_auth`è¿™ä¸ªè‡ªå·±å®ç°çš„æ–¹æ³•:

```python
    def check_auth(self, username, password=None, public_key=None):
        self.rc.push()
        data = {
            "username": username,
            "password": password,
            "public_key": public_key,
            "login_type": 'ST' # SSH Terminal
        }
        logger.debug("Start check auth")
        user, token = g.user_service.login(data)
        result = False
        if user:
            request.user = user
            g.user_service.auth(token=token)
            result = True
        logger.debug("Finish check auth")
        return result
```

è¿™ä¸ªæ–¹æ³•å…¶å®å°è£…äº†å¯†ç å’Œå¯†é’¥è®¤è¯ä¸¤ç§æ–¹å¼, SSHInterfaceæ ¹æ®è¿™ä¸ªæ–¹æ³•è¿”å›çš„True/Falseæ¥ç¡®å®šç”¨æˆ·æ˜¯å¦è®¤è¯æˆåŠŸ, è¯¥æ–¹æ³•å…¶å®æ˜¯è°ƒç”¨äº†`g.user_service.login(data)`è¿™ä¸ªæ–¹æ³•, å‚æ•°æ˜¯ç”¨æˆ·çš„è®¤è¯ä¿¡æ¯, `g`æ˜¯ä¸€ä¸ª`LocalProxy`å®ä¾‹, è¿™é‡Œæš‚æ—¶ç†è§£ä¸ºç±»ä¼¼pythonä¸­çš„`ThreadLocal`, çº¿ç¨‹çš„å±€éƒ¨å˜é‡, `user_service`æ˜¯åœ¨SSHInterfaceç±»åˆå§‹åŒ–çš„æ—¶å€™åˆ›å»ºçš„:

```python
class SSHInterface(paramiko.ServerInterface):
    """ä½¿ç”¨paramikoæä¾›çš„æ¥å£å®ç°ssh server.
    More see paramiko ssh server demo
    https://github.com/paramiko/paramiko/blob/master/demos/demo_server.py
    """
    def __init__(self, app, rc):
        self.app = app
        self.rc = rc
        rc.push()
        request.change_win_size_event = threading.Event()
        g.user_service = UserService(self.app.endpoint) # endpointæ˜¯jmsçš„åœ°å€
```

`UserService`æ˜¯`jumpserver-python-sdk`æä¾›çš„ä¸€ä¸ªç”¨äºç”¨æˆ·ç™»é™†å’Œè·å–ç”¨æˆ·çš„èµ„äº§ä¿¡æ¯çš„ç±».ä¸‹é¢åˆ†åˆ«è¯´è¯´, loginæ–¹æ³•:

```python
    def login(self, data):
        """ç”¨æˆ·ç™»å½•Terminalæ—¶éœ€è¦å‘Jumpserverè¿›è¡Œè®¤è¯, ç™»é™†æˆåŠŸåè¿”å›ç”¨æˆ·å’Œtoken
        data = {
            'username': 'guanghongwei',
            'password': 'password',
            'public_key': 'public key string',
            'login_type': 'ST',  # (('ST', 'SSH Terminal'),
                                 #  ('WT', 'Web Terminal'))
            'remote_addr': '2.2.2.2',  # User ip address not app address
        }
        """
        r, content = self.post('user-auth', data=data, use_auth=False)
        if r.status_code == 200:
            self.token = content['token']
            self.user = content['user']
            self.auth(self.token)
            return to_dotmap(self.user), self.token
        else:
            return None, None
```

è¿™é‡Œå°±æ˜¯ä¸Šé¢æåˆ°çš„ç”¨æˆ·è®¤è¯å¹¶è·å–tokençš„çœŸå®çš„é€»è¾‘, `jumpserver-python-sdk`æ‹¿ç€ç”¨æˆ·çš„å¯†é’¥/å¯†ç å‘jmsä¸­å¿ƒå‘é€äº†ä¸€ä¸ªhttpè¯·æ±‚, è¯·æ±‚æˆåŠŸä¼šè¿”å›ç”¨æˆ·ä»¥åŠç”¨æˆ·çš„token, è¿™é‡Œçš„`to_dotmap`çš„ä½œç”¨æ˜¯è®©pythonçš„å­—å…¸å…·æœ‰`obj.attr`è¿™æ ·è·å–å€¼çš„åŠŸèƒ½.

è¿™é‡Œæœ‰ä¸¤ä¸ªç‚¹éœ€è¦æ³¨æ„:

 * self.postæ˜¯`jumpserver-python-sdk`è‡ªå·±å°è£…çš„requestsçš„æ–¹æ³•, è¯¥æ–¹æ³•ç¬¬ä¸€ä¸ªå‚æ•°ä¸æ˜¯ä¸€ä¸ªhttpåœ°å€, è€Œæ˜¯ä¸€ä¸ªå¯ä»¥è½¬æ¢æˆhttpæ¥å£åœ°å€çš„å­—ç¬¦ä¸², å…·ä½“çš„å¯¹åº”å…³ç³»åœ¨`jumpserver-python-sdk`ç›®å½•ä¸‹çš„config.pyæ–‡ä»¶ä¸­:

```python
API_URL_MAPPING = {
    'terminal-register': '/api/applications/v1/terminal/register/',
    'terminal-heatbeat': '/api/applications/v1/terminal/heatbeat/',
    'send-proxy-log': '/api/audits/v1/proxy-log/receive/',
    'finish-proxy-log': '/api/audits/v1/proxy-log/%s/',
    'send-command-log': '/api/audits/v1/command-log/',
    'send-record-log': '/api/audits/v1/record-log/',
    'user-auth': '/api/users/v1/auth/',
    'my-assets': '/api/perms/v1/user/my/assets/',
    'my-asset-groups': '/api/perms/v1/user/my/asset-groups/',
    'my-asset-groups-assets': '/api/perms/v1/user/my/asset-groups-assets/',
    'assets-of-group': '/api/perms/v1/user/my/asset-group/%s/assets/',
    'my-profile': '/api/users/v1/profile/',
    'system-user-auth-info': '/api/assets/v1/system-user/%s/auth-info/',
    'validate-user-asset-permission':
        '/api/perms/v1/asset-permission/user/validate/',
}
```

* `use_auth=False` è¿™ä¸ªå‚æ•°çš„æ„æ€æ˜¯è¿™é‡Œæ˜¯è®¤è¯æ¥å£, æ‰€ä»¥æ˜¯False, å…¶å®ƒçš„æ¥å£æ¯”å¦‚è·å–ç”¨æˆ·çš„èµ„äº§ç­‰éƒ½éœ€è¦è®¤è¯.
* `self.auth(token)` è¿™å¥è¯å®é™…ä¸Šæ˜¯ç»™è¿™ä¸ªç±»å¢åŠ äº†ä¸€ä¸ª`self._auth = Auth(token=token)`è¿™ä¸ªå±æ€§, `Auth`æ ¸å¿ƒé€»è¾‘å¦‚ä¸‹:

```python
class Auth(object):
    def __init__(self, token=None, access_key_id=None, access_key_secret=None,
                 session_id=None, csrf_token=None):

        if token is not None:
            self.instance = AccessTokenAuth(token)

    def sign_request(self, req):
        return self.instance.sign_request(req)
```

` AccessTokenAuth`ä»£ç å¦‚ä¸‹:

```python
class AccessTokenAuth(object):
    def __init__(self, token):
        self.token = token

    def sign_request(self, req):
        req.headers['Authorization'] = 'Bearer {0}'.format(self.token)
        return req
```

å¯ä»¥çœ‹åˆ°, å½“ç”¨æˆ·è®¤è¯æˆåŠŸåä¼šç»™g.user_serviceå¢åŠ _authè¿™ä¸ªå±æ€§, è¿™ä¸ªå±æ€§çš„è§¦å‘åœºæ™¯æ˜¯å½“ç”¨æˆ·`coco`é€šè¿‡`jumpserver-python-sdk`å‘jmså‘é€è¯·æ±‚çš„æ—¶å€™, å¦‚æœåŠ ä¸Š`user_auth=True`, è¿™æ—¶å€™å°±ä¼šå‡ºå‘self._auth, æ¯”å¦‚å½“è·å–ç”¨æˆ·çš„èµ„äº§çš„æ—¶å€™, æ ¸å¿ƒä»£ç å¦‚ä¸‹:

ApiRequestç±»ä¸­:

```python
class ApiRequest(object):
        if use_auth:
            if not self._auth:
                raise RequestError('Authentication required')
            else:
                self._auth.sign_request(req)
```

å¯ä»¥çœ‹åˆ°è¿™é‡Œå®é™…ä¸Šè§¦å‘çš„åŠ¨ä½œæ˜¯å‘httpå¤´éƒ¨åŠ ä¸Š`Authorization` å­—æ®µ, valueå°±æ˜¯token.è¿™äº›éƒ½ä¼šåœ¨ç”¨æˆ·è®¤è¯å®Œæˆåæ‰§è¡Œè¯·æ±‚ç”¨æˆ·èµ„äº§ç­‰æ“ä½œçš„æ—¶å€™è§¦å‘, å’±ä»¬æ¥ç€èŠç”¨æˆ·è®¤è¯æœåŠ¡ç«¯çš„é€»è¾‘, ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹åˆ°ç”¨æˆ·è®¤è¯è¯·æ±‚çš„æ˜¯`user-auth`, ä¹Ÿå°±æ˜¯`/api/users/v1/auth`æ¥å£, é€šè¿‡ä»£ç æ‰¾åˆ°äº†é€»è¾‘å‡½æ•°å¦‚ä¸‹:

```python
class UserAuthApi(APIView):
    permission_classes = (AllowAny,)

    def post(self, request):
        username = request.data.get('username', '')
        password = request.data.get('password', '')
        public_key = request.data.get('public_key', '')
        login_type = request.data.get('login_type', '')
        login_ip = request.data.get('remote_addr', None)
        user_agent = request.data.get('HTTP_USER_AGENT', '')

        user, msg = check_user_valid( # è¿™ä¸ªå‡½æ•°çš„ä½œç”¨æ˜¯æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨,æ˜¯å¦è¿‡æœŸ,ä»¥åŠå¯†ç /å¯†é’¥æ˜¯å¦è·Ÿæ•°æ®åº“ä¸­å­˜å‚¨çš„ä¸€ç›´, å¦‚æœä¸€æ ·å°±è¿”å›ç”¨æˆ·ä¿¡æ¯, è¿™æ˜¯è®¤è¯çš„æœ€æ ¸å¿ƒçš„é€»è¾‘
            username=username, password=password,
            public_key=public_key)

        if user:
            token = generate_token(request, user)
            write_login_log_async.delay(
                user.username, name=user.name,
                user_agent=user_agent, login_ip=login_ip,
                login_type=login_type)
            return Response({'token': token, 'user': user.to_json()})
        else:
            return Response({'msg': msg}, status=401)
```

è®¤è¯æˆåŠŸåä¼šç»™ç”¨æˆ·è¿”å›token, å…³äºtokençš„æœåŠ¡ç«¯é€»è¾‘çœ‹ä¸‹é¢ä»£ç , æ¯ä¸ªç”¨æˆ·å­˜å‚¨ä¸¤ä¸ªtoken, å…¶ä¸­ä¸€ä¸ªçš„æ ¼å¼ä¸º{userid_ip, token, expiration}, ç”¨äºç”¨æˆ·ç”³è¯·token, è¿™ä¸ªtokenç”¨äºç”¨æˆ·è®¿é—®è‡ªå·±çš„èµ„äº§ç­‰æ¥å£.ç”¨æˆ·ä¼šæŠŠtokenä¿¡æ¯åŠ å…¥è¯·æ±‚å¤´ä¸­, å¦ä¸€ä¸ªtokençš„å­˜å‚¨æ ¼å¼ä¸º{token, userid, expiration}, è¿™ä¸ªtokençš„ä½œç”¨æ˜¯ç”¨æˆ·æºå¸¦tokenå»è¯·æ±‚èµ„æºçš„æ—¶å€™, æœåŠ¡ç«¯åˆ©ç”¨ç”¨æˆ·çš„tokenæ¥æ‰¾åˆ°å…·ä½“æŸä¸ªç”¨æˆ·çš„userid, ç„¶åå»è·å–è¯¥ç”¨æˆ·çš„èµ„äº§ä¿¡æ¯


```python
def generate_token(request, user):
    expiration = settings.CONFIG.TOKEN_EXPIRATION or 3600
    remote_addr = request.META.get('REMOTE_ADDR', '')
    if not isinstance(remote_addr, bytes):
        remote_addr = remote_addr.encode("utf-8")
    remote_addr = base64.b16encode(remote_addr) #.replace(b'=', '')
    token = cache.get('%s_%s' % (user.id, remote_addr))
    if not token:
        token = uuid.uuid4().hex
        print('Set cache: %s' % token)
        cache.set(token, user.id, expiration)
        cache.set('%s_%s' % (user.id, remote_addr), token, expiration)
    return token
```

è¿™é‡Œè¯´ä¸€ä¸‹è‡ªå·±é‡åˆ°çš„ä¸€ä¸ªbug, è¡¨ç°ä¸ºå¤§æ‰¹ç”¨æˆ·ç™»é™†ä¸­ç«¯å£ä¸æ˜¾ç¤ºèµ„äº§åˆ—è¡¨,åæ¥ç ”ç©¶äº†ä¸€ä¸‹, åŸæ¥æ˜¯è·Ÿè®¤è¯æœ‰å…³ç³».å½“ç”¨æˆ·è®¤è¯æˆåŠŸåå°±ä¼šè°ƒç”¨`jumpserver-python-sdk`ä¸­çš„è·å–èµ„äº§çš„å‡½æ•°:

```python
    @cached(TTLCache(maxsize=100, ttl=60))
    def get_my_assets(self):
        """è·å–ç”¨æˆ·è¢«æˆæƒçš„èµ„äº§åˆ—è¡¨
        [{'hostname': 'x', 'ip': 'x', ...,
         'system_users_granted': [{'id': 1, 'username': 'x',..}]
        ]
        """
        r, content = self.get('my-assets', use_auth=True)
        if r.status_code == 200:
            assets = content
        else:
            assets = []
```

æ ¹æ®`my-assets`æ‰¾åˆ°å¯¹åº”çš„åç«¯æ¥å£çš„å¤„ç†é€»è¾‘ä¸ºå¦‚ä¸‹ä»£ç :

```python
class MyGrantedAssetsApi(ListAPIView):
    """æˆæƒç»™ç”¨æˆ·çš„èµ„äº§åˆ—è¡¨
    [{'hostname': 'x','ip': 'x', ..,
      'system_users_granted': [{'name': 'x', .}, ...]
    """
    permission_classes = (IsValidUser,)
    serializer_class = AssetGrantedSerializer

    def get_queryset(self):
        queryset = []
        user = self.request.user
        if user:
            for asset, system_users in get_user_granted_assets(user).items():
                asset.system_users_granted = system_users
                queryset.append(asset)
        return queryset
```

ä¸Šé¢çš„ä»£ç æ˜¯django-rest-frameworkçš„å¼€å‘æ–¹å¼, è¿™é‡Œè·Ÿæˆæƒæœ‰ä»€ä¹ˆå…³ç³»å‘¢?å¦‚æœè¿™ä¸ªç±»æ²¡æœ‰æŒ‡å®š`authentication_classes`çš„è¯, è¯¥ç±»çš„è®¤è¯æ–¹å¼å°±ä¼šæŒ‰ç…§djangoçš„settingsä¸­é…ç½®çš„ä¾æ¬¡å°è¯•:

```python
REST_FRAMEWORK = {
    # Use Django's standard `django.contrib.auth` permissions,
    # or allow read-only access for unauthenticated users.
    'DEFAULT_PERMISSION_CLASSES': (
        'users.permissions.IsSuperUser',
    ),
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'users.authentication.AccessKeyAuthentication',
        'users.authentication.AccessTokenAuthentication',
        'users.authentication.PrivateTokenAuthentication',
        'users.authentication.SessionAuthentication',
    ),
    'DEFAULT_FILTER_BACKENDS': ('django_filters.rest_framework.DjangoFilterBackend',),
}
```

é€šè¿‡è¯·æ±‚å¤´ä¸­æ·»åŠ çš„å­—æ®µæˆ‘ä»¬å¯ä»¥çŸ¥é“, è¿™æ˜¯ä½¿ç”¨AccessTokençš„è®¤è¯æ–¹å¼, ç›¸å…³çš„ä»£ç å¦‚ä¸‹:

```python
class AccessTokenAuthentication(authentication.BaseAuthentication):
    keyword = 'Bearer'
    model = User
    expiration = settings.CONFIG.TOKEN_EXPIRATION or 3600

    def authenticate(self, request):
        # è·å–è¯·æ±‚å¤´ä¸­çš„tokenå­—æ®µ
        auth = authentication.get_authorization_header(request).split()
        if not auth or auth[0].lower() != self.keyword.lower().encode():
            return None

        if len(auth) == 1:
            msg = _('Invalid token header. No credentials provided.')
            raise exceptions.AuthenticationFailed(msg)
        elif len(auth) > 2:
            msg = _('Invalid token header. Sign string '
                    'should not contain spaces.')
            raise exceptions.AuthenticationFailed(msg)

        try:
            token = auth[1].decode()
        except UnicodeError:
            msg = _('Invalid token header. Sign string '
                    'should not contain invalid characters.')
            raise exceptions.AuthenticationFailed(msg)
        return self.authenticate_credentials(token)

    @staticmethod
    def authenticate_credentials(token):
        "cocoé€šè¿‡jumpserver-python-sdkè¯·æ±‚èµ„æºçš„æ—¶å€™éƒ½ä¼šé€šè¿‡è¿™ç§æ–¹å¼è®¤è¯"
        user_id = cache.get(token)
        user = get_object_or_none(User, id=user_id)

        if not user:
            msg = _('Invalid token or cache refreshed.')
            raise exceptions.AuthenticationFailed(msg)
        refresh_token(token, user)
        return user, None
```

é€šè¿‡ä¸Šé¢ä»£ç æˆ‘ä»¬å¯ä»¥çŸ¥é“, ç”¨æˆ·æ¯ä¸€æ¬¡è¯·æ±‚èµ„æºæˆ–è€…ç›¸å…³æ¥å£çš„æ—¶å€™éƒ½ä¼šåˆ·æ–°tokençš„ä¿¡æ¯, ä¹Ÿå°±æ˜¯è°ƒç”¨`refresh_token`è¿™ä¸ªå‡½æ•°, ç„¶åæˆ‘ä»¬çœ‹çœ‹è¿™ä¸ªå‡½æ•°:

```python
def refresh_token(token, user, expiration=3600):
    cache.set(token, user.id, expiration)
```

è¿™æ˜¯æœ‰é—®é¢˜çš„, å› ä¸ºå¦‚æœæˆ‘è‡ªå®šä¹‰è¿‡æœŸæ—¶é—´æ˜¯ä¸€å¤©æˆ–è€…æ›´é•¿çš„æ—¶é—´çš„æ—¶å€™, ç”¨æˆ·åˆ›å»ºçš„ä¸¤ä¸ªtokenå¼€å§‹çš„è¿‡æœŸæ—¶é—´ä¸€æ ·, ä½†æ˜¯å½“ç”¨æˆ·è°ƒç”¨è¿‡ä¸€æ¬¡è‡ªå·±çš„èµ„äº§çš„æ—¶å€™, å°±ä¼šåˆ·æ–°è¿‡æœŸæ—¶é—´æˆä¸º3600ç§’, è¿™å°±ä¼šå¯¼è‡´é€šè¿‡tokenå–ç”¨æˆ·idè¿™ä¸ªtokenæå‰è¿‡æœŸ, ç»™ç”¨æˆ·è¿”å›çš„tokenè¿˜æ²¡è¿‡æœŸ, ä½†æ˜¯æœåŠ¡ç«¯æ²¡æœ‰åŠæ³•é€šè¿‡è®¤è¯, ä¹Ÿå°±æ˜¯æ— æ³•è·å–ç”¨æˆ·çš„èµ„äº§, è¿™å°±æ˜¯é‚£ä¸ªé—®é¢˜çš„æ ¹æœ¬åŸå› , è§£å†³åŠæ³•å°±æ˜¯æŠŠè¿™ä¸ªå‡½æ•°çš„é»˜è®¤å‚æ•°æ”¹æˆå¦‚ä¸‹:

```python
def refresh_token(token, user, expiration=3600):
    cache.set(token, user.id, expiration)
```































