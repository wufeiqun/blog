## 背景介绍

MySQL是中小企业最常使用的关系型数据库, 生产环境一般采用主从的方式搭建, 如果因为一些原因导致主从数据不一致的话还需要重新搭建主从, 最关键的是把主库上的数据同步到从库上, 如果是新搭建的数据库还好说, 毕竟没有数据, 很容易复制过去, 但是如果是一个已经在运行的数据库并且已经有了很多历史数据的话, 如果使用mysqldump的话就会非常慢, 50GB的数据完成备份和恢复至少需要半天, 如果中间稍微有一点点的错误, 基本上就会花费一天的时间了, 所以找到一个更快速的备份恢复MySQL的工具是非常有必要的.



## mysqldump

mysqldump优点是工具自带, 非常成熟. 可以备份全库, 指定表等灵活备份方式. 缺点是逻辑备份, 当数据量比较大的时候速度非常慢, 如果数据量比较小的时候, 比如小于10GB. 非常适合使用该工具.

* 停止主从节点上的主从同步配置

```
# master节点和slave节点都要执行, 不然往从库里面灌数据的时候会写入到主库
# 执行完以后, 两个节点就成了2个独立的节点了
# 执行reset命令的时候会释放relay log
stop slave;
reset slave all;
```



* 将从库设置为只读

如果场景是操作过程中可能会出现主从切换的时候, 可以把从库设置为只读, 防止操作过程中主从切换导致写入到从库.

```
# 从库执行如下SQL, 这个只能阻止普通用户的写入, 不能阻止root用户, 所以业务中一般不让使用root用户
SET GLOBAL read_only = ON;
show global variables like 'read_only';
```



* 备份

```shell
mysqldump  -uroot  -p'xxx' --host=192.168.1.1 --port=3306 --default-character-set=utf8mb4  --single-transaction --set-gtid-purged=off  --databases dbname  --add-drop-table --quick --master-data=2 > data.sql
```

参数含义:

```
--single-transaction 把该次备份当做一个完整的事务, 保证该次备份的完整性, 同时不影响其它的读写操作.
--set-gtid-purged=off 只导数据, 不清空目标库的gtid信息使用主库的gtid, 90%场景都用OFF就行
--add-drop-table 备份的SQL文件中创建表之前会加上drop table
--quick 一边从 MySQL 读数据，一边立刻写到 SQL 文件里，不把整张表先加载到内存中。主要减少客户端的内存占用, 而不是服务端的内存. 速度不慢.
--master-data=2 以注释的形式记录下当时主库的 binlog 文件名和位置, 方便后续做主从, 如果是1的话就不是注释, 非常危险了 
```



* 恢复

```
mysql --max_allowed_packet=1G -h192.168.1.1 -P 3306 -uroot -p'xxx'  --default-character-set=utf8mb4  < data.sql 
```

参数含义:

```
--max_allowed_packet=1G  MySQL客户端和服务端一次通信允许的最大字节大小, 防止太大导致内存溢出等, 需要客户端和服务端同时配置
```



* 重建slave节点主从

```
# 先执行 head -30 data.sql 获取文件和位置, 把相关参数填写到如下的命令行中, 然后执行命令。

change master to master_host='192.168.1.1', master_port=3306, master_user='root', master_password='xxx', master_log_file='mysql-bin.000174',master_log_pos=733231250;

start slave;

# 查看状态
show slave status;

  可以看到 Slave_IO_Running 和 Slave_SQL_Running 均为yes，说明主从同步已经恢复；
```

* 恢复master节点主从

这里是重建双主架构的方式.

```
# 在从库上执行如下命令获取binlog文件名字和pos位置

show master status\G;


# 然后在master上执行
change master to master_host='192.168.1.1', master_port=3306, master_user='root', master_password='xxx', master_log_file='mysql-bin.000174',master_log_pos=12345;

start slave;

# 查看状态
show slave status\G;
```



## mydumper

mydumper可以理解为多线程的mysqldump, 经过测试在数据量大的时候, 会比mysqldump快好几倍, 尤其是导出, 会把带宽跑满那种, 导入的话, 因为会写日志, 速度提升的不太明显, 但是至少是翻一倍速度的.

> 使用这个工具最好别在MySQL的数据目录, 因为会创建数据库同名的目录, MySQL数据目录默认就会有这个目录, 会覆盖掉, 最好在一个单独的服务器上搞.



* 备份

```
mydumper -h 192.168.1.1 -u root -P 3306 -p xxx -B dbname -o 备份路径  --trx-tables --threads=8 --default-character-set=utf8mb4 --rows=500000
```

参数含义:

```
-o 备份路径, 这里要指定一个目录, 备份的时候会创建一个以dbname为名称的目录, 里面都是恢复用到的SQL文件, 最好指定一个不存在的路径
--trx-tables 告知mydumper是事务性表, 也就是备份的都是事务性的, 这样mydumper就会启动一个长长的事务来备份, 不会锁表, 不然会锁表再操作, 现在的MySQL使用一般都是innodb, 直接加上该参数就行
--threads=8 线程数
--rows=500000  这么多行切分成一个trunk, 不设置这个数字的话, 每个表一个线程, 如果遇到大表就很慢了

```



* 恢复

```
myloader -h 192.168.1.1 -u root -P 3306 -p xxx -d 备份路径  --threads=8  --drop-table
```

参数含义:

```
-d 备份路径,  复制备份的时候写的路径就行
--drop-table 创建表之前先drop表, 我开始想着多线程会有问题, 其实工具使用单个线程处理DDL, 多线程只是在复制数据的时候使用, 没有问题.
```



* 重建主从

方式同mysqldump, binlog和position在备份目录下的`metadata`文件中, 示例如下:

```
# more metadata
# Started dump at: 2025-12-16 09:56:44
[config]
quote-character = BACKTICK

[myloader_session_variables]
SQL_MODE='NO_AUTO_VALUE_ON_ZERO,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION' /*!40101

[source]
# Channel_Name = '' # It can be use to setup replication FOR CHANNEL
# executed_gtid_set = "76b2b516-735d-11f0-8049-6a67bb392478:1-6646"
# SOURCE_LOG_FILE = "mysql-bin.000010"
# SOURCE_LOG_POS = 996266970
```



## xtrabackup

该方式适用于部署在虚拟机上的MySQL, 因为是物理方式备份, 部署在Kubernetes里面的需要跟MySQL部署在一起的container才可以访问PVC. 暂时比较麻烦.



## 参考链接



* https://mydumper.github.io/mydumper/docs/html/index.html
* 
